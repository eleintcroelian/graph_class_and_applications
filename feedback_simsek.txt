FILE:          Graph.hpp
FUNCTIONALITY  

COMMENTS:
-in add_edge you do not return an edge that always has node1 == a (see @return above). I suspect that it is becasue if b>a then you store_n1_n2_edge[b._node_id] and not the other way round. thus the line below fails

RELEVANT CODE:
size_type existingedgeid = _n1_n2_edge[a._node_id][b._node_id]; // If edge already exists
    return _Edge_Vector[existingedgeid];                            // return it

POINTS DEDUCTED: 1


--------------------------
FILE:          Graph.hpp
DESIGN         

COMMENTS:
-well done with nested maps, very close to getting the implimentation correct. Howeever nedge and nnode are unneccecary, making calls to a vector size() are low computational cost.

RELEVANT CODE:
std::vector<Point> _Point_Vector; // Vector holding points of nodes (ordered)
  std::vector<node_type> _Node_Vector; // Vector holding Nodes (ordered)
  std::map<size_type, std::map<size_type, size_type>> _n1_n2_edge; 
                                      // Nested map with node1_id - [node2_id - edge_id] structure
  std::vector<edge_type> _Edge_Vector; // Vector holding Edge objects (ordered)
  size_type _n_node = 0; // Total number of nodes
  size_type _n_edge = 0; // Total number of edges

                  


--------------------------

GRADING TA                  
SUNet ID: lwarne, GitHub ID lwarne
###################################################

FUNCTIONALITY SCORE:                     ok
###################################################

DESIGN SCORE:                             +
###################################################

STYLE SCORE:                              +
###################################################

WRITEUP SCORE:                            +
###################################################
If you have any problem about grading result, please file an issue in your GitHub repo.