\documentclass[12pt,letterpaper,twoside]{article}

\usepackage{cme212}

\begin{document}

{\centering \textbf{Paper Exercise 0 -- C++ Warm-up\\ Due Tuesday, January 15th in class} \par}
\vspace*{-8pt}\noindent\rule{\linewidth}{1pt}

\paragraph{Question 0: Lecture 0} The poor ampersand (\&) and asterisk (*) get used in a lot of different ways in C++. Given the following declaration and initialization for {\tt a}, {\tt b}, and {\tt c}:
\begin{verbatim}
int a = 2, b = -3, c = -7;
\end{verbatim}
\vspace{-1ex}
What can you say about the values of the following variables {\tt d} through {\tt h}:
{\small
\begin{cpp}
int* d = &c;
int& e = a;
int f  = b*c;
int g  = *&a;
int* h = a;
\end{cpp}
}


\vspace{-2ex}
\paragraph{Question 1: Lecture 0} What is the output of the program below? Explain in your own words why.
\begin{cpp}
#include <iostream>
int f(int& a, int& b) {
  a = 3;
  b = 4;
  return a + b;
}
int main() {
  int a = 1, b = 2;
  int c = f(a, a);  // Not a typo: calling f() with both arguments set to 'a'.
  std::cout << a << b << c << std::endl;
}
\end{cpp}


\vspace{-2ex}
\paragraph{Question 2: Lecture 0} What is the output of the program below, and why?  Recall: \href{https://en.cppreference.com/w/cpp/language/initializer_list}{member initializer lists}.
{\small
\begin{cpp}
#include <iostream>
struct A {
  A() : val(2) {}
  A(int v) : val(v+2) { v += 2; }
  A(A& a) : val(a.val+2) { a.val += 2; } 
  int val;
};
int main(int argc, char** argv) {
  A a1;
  A a2(5);
  A a3(a1.val);
  A a4 = a3;  
  std::cout << a1.val << a2.val << a3.val << a4.val << std::endl;
}
\end{cpp}
}
\paragraph{Question 2: Lecture 0}
For each of the following code snippets state if they will work and why/why not.
\begin{cpp}
	const int val = 9;
	int* ptr = &val;
	*ptr = 2;
\end{cpp}

\begin{cpp}	
	int val = 9;
	const int* ptr = &val;
	*ptr = 2;
\end{cpp}
\begin{cpp}		
	const int val1 = 9;
	const int* ptr = &val1;
	const int val2 = 8;
	ptr = &val2;
\end{cpp}
\begin{cpp}		
	const int val1 = 9;
	int* const ptr = &val1;
	const int val2 = 8;
	ptr = &val2;
\end{cpp}

\begin{cpp}		
	int val = 9;
	const int* ptr = &val;
	std::const_cast<int*> ptr = 2;
\end{cpp}

\begin{cpp}		
	const int val = 9;
	const int* ptr = &val;
	std::const_cast<int*> ptr = 2;
\end{cpp}

\paragraph{Question 3: Lecture 0}
Why does the following code not work? Modify the \texttt{Student} class so the code does work.

\begin{cpp}		
	class Student
	{
		int ID_ = 10;
		public:
			int getID(){return this->ID_;}
	}
	
	int main()
	{
		const Student Alex;
		std::cout<<Alex.getID()<<std::endl;
	}
\end{cpp}

\paragraph{Question 4: Lecture 1}
Rewrite the following code so you can find the bug when someone gives an invalid index for the \texttt{vector}. Using
\begin{enumerate}
	\item A \texttt{print} statement.
	\item An \texttt{assert} statement.
	\item A macro.
	\item A pause statement.
\end{enumerate}

\begin{cpp}
	double access_vec(std::vector<double> vec, unsigned int idx){
		return vec[idx];
	}
\end{cpp}

\end{document}
